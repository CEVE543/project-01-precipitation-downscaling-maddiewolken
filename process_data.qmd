```{julia}
#| output: false
using Dates
using MultivariateStats
using Plots
using NCDatasets
using StatsBase
using Unitful
```

# Data
```{julia}
precip_ds = NCDataset("data/precip_tx.nc")
precip_time = precip_ds["time"][:]
precip_lon = precip_ds["lon"][:]
precip_lat = precip_ds["lat"][:]
precip = precip_ds["precip"][:, :, :]

display(precip_ds[:precip]) # learn about variable
close(precip_ds)
```

```{julia}
#| output: false
include("get_data.jl")
```

```{julia}
data_dict = open_mfdataset(["data/raw/2m_temperature_2000.nc", "data/raw/2m_temperature_2001.nc", "data/raw/2m_temperature_2002.nc", "data/raw/2m_temperature_2003.nc", "data/raw/2m_temperature_2004.nc", "data/raw/2m_temperature_2005.nc", "data/raw/2m_temperature_2006.nc"], "t2m");
```

```{julia}
#Display first 5 rows of data_dict to view the new dataframe
first(data_dict, 5)
```
    
```{julia}
#Display last 5 rows of time in data_dict to check to make sure all the files were combined
last(data_dict["time"], 5)
```

```{julia}
#Make sure temp was read in correctly into 3D array
println(length(data_dict["t2m"]))
```

```{julia}
#Rename data_dict to temp_ds
temp_ds = data_dict
temp_time = temp_ds["time"][:]
temp_lon = temp_ds["longitude"][:]
temp_lat = temp_ds["latitude"][:]
temp = temp_ds["t2m"][:, :, :]

display(temp_ds["t2m"])
```

```{julia}
#Check if latitude needs to be reversed
temp_lat
#Handle the fact that the latitudes are reversed
temp_lat = reverse(temp_lat)
```

```{julia}
#Need to reverse temp data to match reversed latitudes
temp = reverse(temp; dims=2)
```

```{julia}
#Run a quick plot to make sure everything is working well
heatmap(
    temp_lon[1:66],  # Adjusted temporarily to match the size of the data
    temp_lat[1:27],  #Adjusted temporarily to match the size of the data
    temp[:, :, 1]';
    xlabel="Longitude",
    ylabel="Latitude",
    title="Temperature on $(temp_time[1])"
)
```

```{julia}
#Change longitude format from lon3 ot lon1
precip_lon .=mod.((precip_lon .+180),360) .-180
```

```{julia}
#I want to subset the temp_ds data to only include Texas-ish region of precip_ds
#Check the range of the latitudes and longitudes for the precip_ds
min_precip_lat = minimum(precip_lat)
max_precip_lat = maximum(precip_lat)
min_precip_lon = minimum(precip_lon)
max_precip_lon = maximum(precip_lon)

println("Minimum Latitude: $min_precip_lat, Maximum Latitude: $max_precip_lat")
println("Minimum Longitude: $min_precip_lon, Maximum Longitude: $max_precip_lon")
```

```{julia}
# Find unique latitudes and longitudes with at least one associated non-zero temperature observation (basically this is getting the latitude and longitude lengths to match the latitude and longitudes in temp)
unique_latitudes = Set()
unique_longitudes = Set()

for lat in 1:size(temp, 1)
    for lon in 1:size(temp, 2)
        if any(temp[lat, lon, :] .!= 0)
            push!(unique_latitudes, lat)
            push!(unique_longitudes, lon)
        end
    end
end

# Convert sets to arrays if needed. Filtered variables contain the same length as in temp
filt_lat = collect(unique_latitudes)
filt_lon = collect(unique_longitudes)
```

```julia
temp_lat2 = temp_lat[1:66]
temp_lon2 = temp_lon[1:27]

# Now, you can check the sizes
println(size(temp_lat2))
println(size(temp_lon2))
```


```{julia}
# Substitute temp_lat and temp_lon for filtered
temp_ds["latitude"] = filt_lat
temp_ds["longitude"] = filt_lon
```

```{julia}
# Define the latitude and longitude ranges
min_temp_lat = 25.25
max_temp_lat = 36.75
min_temp_lon = -101.75
max_temp_lon = -90.25

# Create logical indices based on the specified range
lat_indices = (filt_lat .>= min_temp_lat) .& (filt_lat .<= max_temp_lat)
lon_indices = (filt_lon .>= min_temp_lon) .& (filt_lon .<= max_temp_lon)

# Use logical indexing to subset the data
filtered_filt_lat = filt_lat[lat_indices]
filtered_filt_lon = filt_lon[lon_indices]
filtered_temp = temp[lat_indices, lon_indices, :]
filtered_time = time  # Assuming time is not subject to filtering
```

```julia

# Define the latitude and longitude ranges
min_temp_lat = 25.25
max_temp_lat = 36.75
min_temp_lon = -101.75
max_temp_lon = -90.25

# Find the indices for latitude and longitude ranges
lat_indices = findall(min_temp_lat .<= temp_ds["latitude"] .<= max_temp_lat)
lon_indices = findall(min_temp_lon .<= temp_ds["longitude"] .<= max_temp_lon)

# Apply the indices to subset the dictionary to just the Texas-ish region
tx_temp_ds = Dict(
    "latitude" => temp_ds["latitude"][lat_indices],
    "longitude" => temp_ds["longitude"][lon_indices],
    "time" => temp_ds["time"],
    "t2m" => temp_ds["t2m"][lat_indices, lon_indices, :]
)

tx_temp_lat = temp_ds["latitude"][lat_indices]
tx_temp_lon = temp_ds["longitude"][lon_indices]
tx_temp_time = temp_ds["time"]
tx_temp_data = temp_ds["t2m"][lat_indices, lon_indices, :]
```


```{julia}
#Run a quick plot to make sure everything is working well
heatmap(
    tx_temp_lon,  # Adjusted temporarily to match the size of the data
    tx_temp_lat,  #Adjusted temporarily to match the size of the data
    tx_temp_data[:, :, 1]';
    xlabel="Longitude",
    ylabel="Latitude",
    title="Temperature on $(temp_time[1])"
)
```

```{julia}
#Need to process the precip data further
#Need to handle the fact that the latitudes are reversed
precip_lat #can check if they are good or need to be reversed (run in terminal to check without running the full cell)
precip_lat = reverse(precip_lat)
precip = reverse(precip; dims=2)
```

```julia
#Run a quick plot to make sure everything is working well
heatmap(
    precip_lon,
    precip_lat,
    precip[:, :, 1]';
    xlabel="Longitude",
    ylabel="Latitude",
    title="Precipitation on $(precip_time[1])"
)
```

